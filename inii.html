<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PALADIN OF THE KAREN GOD — Puzzle Platformer (Single-File)</title>
<style>
  :root{
    --bg:#07070b;
    --panel:#0e0f16cc;
    --panel2:#15172aa8;
    --txt:#e9ecff;
    --muted:#aeb6ff;
    --good:#43ffb6;
    --bad:#ff4d7d;
    --warn:#ffd24a;
    --cyan:#4fe2ff;
    --vio:#b86bff;
    --shadow: 0 16px 50px rgba(0,0,0,.55);
    --radius: 18px;
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 65% 20%, #15163a 0%, var(--bg) 55%, #05050a 100%); overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";}
  canvas{display:block; width:100vw; height:100vh;}
  #ui{
    position:fixed; inset:0; pointer-events:none;
    color:var(--txt);
  }
  .hud{
    position:absolute; left:16px; top:16px; display:flex; flex-direction:column; gap:10px;
    pointer-events:none;
  }
  .row{display:flex; gap:10px; align-items:center;}
  .pill{
    background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.12);
    border-radius:999px;
    padding:10px 12px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
  }
  .pill b{font-weight:800; letter-spacing:.02em}
  .bar{
    width:240px; height:10px; border-radius:999px; overflow:hidden;
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.12);
  }
  .fill{height:100%; width:0%;}
  #topRight{
    position:absolute; right:16px; top:16px; display:flex; flex-direction:column; gap:10px; align-items:flex-end;
  }
  .mini{
    font-size:12px; color:var(--muted);
  }
  .btnHint{
    pointer-events:auto;
    display:inline-flex; align-items:center; gap:8px;
    cursor:pointer;
    user-select:none;
    transition:transform .12s ease, filter .12s ease;
  }
  .btnHint:hover{transform:translateY(-1px); filter:brightness(1.08);}
  .kbd{
    font-size:11px; color:var(--txt);
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.25);
    padding:3px 7px; border-radius:8px;
  }
  #banner{
    position:absolute; left:50%; top:16px; transform:translateX(-50%);
    max-width:min(860px, calc(100vw - 40px));
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.14);
    border-radius:999px;
    padding:10px 14px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    opacity:0; transition:opacity .25s ease, transform .25s ease;
    pointer-events:none;
    text-align:center;
  }
  #banner.show{opacity:1; transform:translateX(-50%) translateY(0);}
  #banner .title{font-weight:900; letter-spacing:.02em}
  #banner .sub{color:var(--muted); font-size:12px}
  #toast{
    position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
    max-width:min(820px, calc(100vw - 40px));
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.14);
    border-radius: var(--radius);
    padding:12px 14px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    opacity:0; transform:translateX(-50%) translateY(8px);
    transition:opacity .18s ease, transform .18s ease;
    pointer-events:none;
  }
  #toast.show{opacity:1; transform:translateX(-50%) translateY(0);}
  #toast .narr{font-weight:800; letter-spacing:.01em}
  #toast .txt{color:var(--muted); margin-top:6px; font-size:13px; line-height:1.25;}
  #overlay{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:radial-gradient(800px 600px at 50% 30%, rgba(0,0,0,.55), rgba(0,0,0,.82));
    opacity:0; pointer-events:none;
    transition:opacity .2s ease;
  }
  #overlay.show{opacity:1; pointer-events:auto;}
  .card{
    width:min(980px, calc(100vw - 34px));
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    border:1px solid rgba(255,255,255,.16);
    border-radius: 24px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(12px);
    padding:18px;
    color:var(--txt);
    transform:translateY(10px) scale(.99);
    transition:transform .2s ease;
  }
  #overlay.show .card{transform:translateY(0) scale(1);}
  .card h1{
    margin:0 0 6px 0;
    font-size:18px;
    letter-spacing:.02em;
  }
  .card p{margin:0; color:var(--muted); font-size:13px; line-height:1.35;}
  .grid{
    display:grid; grid-template-columns:1.15fr .85fr; gap:14px; margin-top:14px;
  }
  @media (max-width: 900px){
    .grid{grid-template-columns:1fr;}
  }
  .panel{
    background:rgba(0,0,0,.22);
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px;
    padding:14px;
  }
  .panel h2{margin:0 0 8px 0; font-size:13px; letter-spacing:.04em; color:var(--txt); text-transform:uppercase}
  ul{margin:8px 0 0 18px; padding:0; color:var(--muted); font-size:13px; line-height:1.35;}
  li{margin:6px 0;}
  .cta{
    display:flex; gap:10px; flex-wrap:wrap; margin-top:14px;
  }
  button{
    pointer-events:auto;
    cursor:pointer;
    user-select:none;
    border:none;
    border-radius:14px;
    padding:10px 12px;
    font-weight:800;
    letter-spacing:.02em;
    color:var(--txt);
    background:linear-gradient(180deg, rgba(79,226,255,.22), rgba(184,107,255,.14));
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.16);
    transition:transform .12s ease, filter .12s ease;
  }
  button:hover{transform:translateY(-1px); filter:brightness(1.06);}
  button.secondary{
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
  }
  .smallnote{margin-top:10px; font-size:12px; color:rgba(233,236,255,.7)}
  .blink{
    animation: blink 1.1s ease-in-out infinite;
  }
  @keyframes blink{0%,100%{opacity:.45}50%{opacity:1}}
  /* CRT-ish overlay */
  #crt{
    position:fixed; inset:0; pointer-events:none;
    background:
      linear-gradient(rgba(255,255,255,.05), rgba(255,255,255,0)),
      repeating-linear-gradient(
        to bottom,
        rgba(0,0,0,.0) 0px,
        rgba(0,0,0,.0) 2px,
        rgba(0,0,0,.18) 3px
      );
    mix-blend-mode: overlay;
    opacity:.55;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <div class="hud">
    <div class="row">
      <div class="pill">
        <b>Manager Tokens</b> <span id="tokens">0</span><span class="mini">/3</span>
      </div>
      <div class="pill">
        <b>Complaint Meter</b>
        <div class="bar" title="If this fills up, the Karen God resets you to the last checkpoint (not game over).">
          <div id="complaintFill" class="fill" style="background:linear-gradient(90deg,var(--warn),var(--bad));"></div>
        </div>
      </div>
    </div>
    <div class="pill mini">
      Checkpoint: <span id="cp">1</span> • Deaths: <span id="deaths">0</span> • Time: <span id="time">0:00</span>
    </div>
  </div>

  <div id="topRight">
    <div class="pill btnHint" id="btnHelp" title="How to play">
      <span class="kbd">H</span> <b>How to play</b>
    </div>
    <div class="pill btnHint" id="btnRestart" title="Restart run">
      <span class="kbd">R</span> <b>Restart</b>
    </div>
    <div class="pill btnHint" id="btnSound" title="Toggle sound">
      <span class="kbd">M</span> <b>Sound</b> <span id="soundState" class="mini">ON</span>
    </div>
  </div>

  <div id="banner">
    <div class="title">PALADIN OF THE KAREN GOD</div>
    <div class="sub">Puzzle-platformer • Push, flip, appease • Beat it in ~2–5 minutes</div>
  </div>

  <div id="toast" aria-live="polite">
    <div class="narr">Narrator</div>
    <div class="txt" id="toastTxt">...</div>
  </div>
</div>

<div id="overlay" role="dialog" aria-modal="true" aria-label="How to play">
  <div class="card">
    <h1>How to play (and how to win)</h1>
    <p>You’re a paladin. Your god is… a Karen. Reach the service desk and collect <b>3 Manager Tokens</b> by solving short room puzzles. Keep the <b>Complaint Meter</b> from maxing out by moving with purpose and grabbing coupons.</p>

    <div class="grid">
      <div class="panel">
        <h2>Controls</h2>
        <ul>
          <li><b>Move:</b> Arrow keys / WASD</li>
          <li><b>Jump:</b> Space / W / ↑</li>
          <li><b>Interact:</b> <b>E</b> (flip levers, pray at shrines)</li>
          <li><b>Restart:</b> <b>R</b> (full reset)</li>
          <li><b>Help:</b> <b>H</b></li>
          <li><b>Sound toggle:</b> <b>M</b></li>
        </ul>
      </div>
      <div class="panel">
        <h2>Rules</h2>
        <ul>
          <li><b>Crates</b> can be pushed onto <b>pressure plates</b> to open <b>doors</b>.</li>
          <li><b>Levers</b> toggle doors—sometimes for a short time.</li>
          <li><b>Spikes</b> respawn you at the last checkpoint (no harsh punishment).</li>
          <li><b>Coupons</b> reduce the Complaint Meter (your holy offering).</li>
          <li><b>Win:</b> get 3 tokens + reach the <b>Service Desk</b>.</li>
        </ul>
      </div>
    </div>

    <div class="cta">
      <button id="btnPlay">Play</button>
      <button class="secondary" id="btnClose">Close</button>
    </div>

    <div class="smallnote">
      Narration is a playful <i>parody vibe</i> (laid-back West Coast rap energy) — not the real person.
    </div>
  </div>
</div>

<div id="crt"></div>

<script>
(() => {
  // ============================================================
  // Paladin of the Karen God — single-file canvas game
  // No external assets, all visuals procedural.
  // ============================================================

  // ----- Canvas setup
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function resize() {
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
  }
  addEventListener('resize', resize);
  resize();

  // ----- UI refs
  const elTokens = document.getElementById('tokens');
  const elComplaintFill = document.getElementById('complaintFill');
  const elCP = document.getElementById('cp');
  const elDeaths = document.getElementById('deaths');
  const elTime = document.getElementById('time');
  const banner = document.getElementById('banner');
  const toast = document.getElementById('toast');
  const toastTxt = document.getElementById('toastTxt');
  const overlay = document.getElementById('overlay');
  const btnHelp = document.getElementById('btnHelp');
  const btnRestart = document.getElementById('btnRestart');
  const btnSound = document.getElementById('btnSound');
  const soundState = document.getElementById('soundState');
  const btnPlay = document.getElementById('btnPlay');
  const btnClose = document.getElementById('btnClose');

  // ----- Input
  const keys = new Set();
  const pressed = new Set();
  function keyDown(e){
    const k = e.key.toLowerCase();
    if (!keys.has(k)) pressed.add(k);
    keys.add(k);
    // prevent page scroll
    if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key.toLowerCase()) || e.key === ' ') e.preventDefault();
  }
  function keyUp(e){
    keys.delete(e.key.toLowerCase());
  }
  addEventListener('keydown', keyDown, {passive:false});
  addEventListener('keyup', keyUp);

  // ----- Audio (procedural)
  let audioOn = true;
  let ac = null;
  function ensureAudio(){
    if (!ac) ac = new (window.AudioContext || window.webkitAudioContext)();
    if (ac.state === 'suspended') ac.resume();
  }
  function beep(freq=440, dur=0.06, type='sine', vol=0.08){
    if (!audioOn) return;
    ensureAudio();
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g);
    g.connect(ac.destination);
    const t = ac.currentTime;
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.start(t);
    o.stop(t + dur);
  }
  function chord(base=220){
    beep(base, 0.08, 'triangle', 0.06);
    beep(base*1.25, 0.08, 'triangle', 0.05);
    beep(base*1.5, 0.08, 'triangle', 0.045);
  }
  function thud(){
    beep(110, 0.05, 'square', 0.06);
    beep(55, 0.08, 'sine', 0.05);
  }
  function sizzle(){
    beep(880, 0.03, 'sawtooth', 0.04);
    beep(660, 0.03, 'sawtooth', 0.03);
  }

  // ----- Helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  function rand(n=1){return Math.random()*n;}
  function randi(n){return (Math.random()*n)|0;}
  function now(){return performance.now();}
  function rectsOverlap(a,b){
    return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
  }

  // ----- Camera + world scale
  const TILE = 32;
  const WORLD_W = 40 * TILE;
  const WORLD_H = 17 * TILE;

  // ----- “Karen God” flavor: complaint meter + narrator lines
  const narrator = {
    queue: [],
    shownAt: 0,
    show(ms, title, text){
      this.queue.push({title, text, at: now(), ms});
    },
    tick(){
      if (!this.queue.length) return;
      const cur = this.queue[0];
      if (this.shownAt === 0){
        this.shownAt = now();
        toast.classList.add('show');
        toast.querySelector('.narr').textContent = cur.title;
        toastTxt.textContent = cur.text;
      }
      if (now() - this.shownAt > cur.ms){
        this.queue.shift();
        this.shownAt = 0;
        toast.classList.remove('show');
      }
    }
  };

  // playful “West Coast rap narrator vibe” without claiming to be the real person
  const VIBE = {
    say(text, emphasis=false, ms=2600){
      narrator.show(ms, emphasis ? "Narrator (D-O-double-G vibe)" : "Narrator (laid-back rap vibe)", text);
    }
  };

  // ----- Particles
  const parts = [];
  function spawnSpark(x,y, n=8, colA=[79,226,255], colB=[184,107,255]){
    for (let i=0;i<n;i++){
      const t = Math.random();
      const r = lerp(colA[0], colB[0], t)|0;
      const g = lerp(colA[1], colB[1], t)|0;
      const b = lerp(colA[2], colB[2], t)|0;
      parts.push({
        x, y,
        vx: (Math.random()*2-1)*220,
        vy: (Math.random()*2-1)*220,
        life: 0.6 + Math.random()*0.4,
        age: 0,
        r,g,b,
        s: 1 + Math.random()*2
      });
    }
  }
  function spawnDust(x,y, n=10){
    for (let i=0;i<n;i++){
      parts.push({
        x, y,
        vx: (Math.random()*2-1)*120,
        vy: -Math.random()*140,
        life: 0.5 + Math.random()*0.25,
        age: 0,
        r: 235, g: 236, b: 255,
        s: 0.7 + Math.random()*1.4
      });
    }
  }

  // ----- Level encoding
  // Legend (tiles):
  // # wall
  // . empty
  // ^ spikes
  // S shrine/checkpoint
  // D door (solid unless opened)
  // P plate (opens linked door while pressed by crate/player)
  // L lever (toggles linked door; some timed)
  // C coupon (reduces complaint)
  // T token (collect)
  // E exit/service desk (needs 3 tokens)
  // B crate spawn
  //
  // Links via metadata arrays.
  const level = [
    "########################################",
    "#..............C..............#.......E#",
    "#..S..######..#####..#######..#..######",
    "#.....#....#..#...#..#.....#..#..#....##",
    "#..B..#..P.#..# L #..#  T  #..#..#..^..#",
    "######..####..#...#..#.....#..#..#.....#",
    "#..........#..#####..#######..#..#####.#",
    "#..######..#..................#........#",
    "#..#....#..###########..###########..###",
    "#..#..T.#...........#..#.........#....##",
    "#..#######..#####..#..#..#####..######.#",
    "#........#..#...#..#..#..#...#.........#",
    "#..B..P..#..# D #..#..#..# S #..C..T...#",
    "##########..#...#..####..#...###########",
    "#...........#####........#.............#",
    "#....^...................#..C..........#",
    "########################################"
  ];

  // Convert to tile grid + entities
  const grid = level.map(row => row.split(''));
  const H = grid.length;
  const W = grid[0].length;

  function tileAt(tx,ty){
    if (tx<0||ty<0||tx>=W||ty>=H) return '#';
    return grid[ty][tx];
  }
  function setTile(tx,ty,ch){
    if (tx<0||ty<0||tx>=W||ty>=H) return;
    grid[ty][tx]=ch;
  }

  // Door objects for linkage
  const doors = [];  // {tx,ty, open, kind, tmr}
  const plates = []; // {tx,ty, doorIndex}
  const levers = []; // {tx,ty, doorIndex, timed, duration, state}
  const items = [];  // {x,y, kind:'coupon'|'token', taken:false}
  const spikes = [];
  const shrines = [];
  const crates = [];

  let exitPos = {x:0,y:0};

  // Parse
  (function parse(){
    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const ch = grid[y][x];
        if (ch === 'D'){
          doors.push({tx:x,ty:y, open:false, kind:'door', tmr:0});
        }
        if (ch === 'P'){
          plates.push({tx:x,ty:y, doorIndex:-1});
        }
        if (ch === 'L'){
          levers.push({tx:x,ty:y, doorIndex:-1, timed:true, duration:4.2, state:false});
        }
        if (ch === 'C'){
          items.push({x:x*TILE+TILE*0.5, y:y*TILE+TILE*0.5, kind:'coupon', taken:false, bob:rand(999)});
          setTile(x,y,'.');
        }
        if (ch === 'T'){
          items.push({x:x*TILE+TILE*0.5, y:y*TILE+TILE*0.5, kind:'token', taken:false, bob:rand(999)});
          setTile(x,y,'.');
        }
        if (ch === '^'){
          spikes.push({tx:x,ty:y});
        }
        if (ch === 'S'){
          shrines.push({tx:x,ty:y});
        }
        if (ch === 'B'){
          crates.push({x:x*TILE+6, y:y*TILE+6, w:TILE-12, h:TILE-12, vx:0, vy:0, grounded:false});
          setTile(x,y,'.');
        }
        if (ch === 'E'){
          exitPos = {x:x*TILE+TILE/2, y:y*TILE+TILE/2, tx:x, ty:y};
          setTile(x,y,'.');
        }
      }
    }

    // Link puzzles in a simple, readable way:
    // Plate #0 opens Door #0 (top-left-ish)
    // Lever toggles Door #0 too (shortcut)
    // Plate #1 opens Door #1 (mid)
    // Lever #0 toggles Door #1 timed
    // (If fewer doors exist, clamp safely)
    plates.forEach((p,i)=> p.doorIndex = clamp(i,0,doors.length-1));
    levers.forEach((l,i)=> l.doorIndex = clamp(i+1,0,doors.length-1));
    // If there is only 1 door, both controls point to it.
    if (doors.length===1){
      plates.forEach(p=>p.doorIndex=0);
      levers.forEach(l=>l.doorIndex=0);
    }
  })();

  // ----- Collision helpers
  function isSolidTile(ch){
    if (ch === '#') return true;
    if (ch === 'D'){
      // look up door open state
      const d = doors.find(dd=>dd.tx===0 && dd.ty===0); // placeholder
      return true;
    }
    return false;
  }
  function doorSolidAt(tx,ty){
    for (const d of doors){
      if (d.tx===tx && d.ty===ty) return !d.open;
    }
    return false;
  }
  function tileSolid(tx,ty){
    const ch = tileAt(tx,ty);
    if (ch === '#') return true;
    if (ch === 'D') return doorSolidAt(tx,ty);
    return false;
  }
  function tileSpike(tx,ty){
    return tileAt(tx,ty) === '^';
  }

  function rectCollideWithWorld(r){
    // returns list of solid tile rects near r
    const minX = Math.floor(r.x / TILE) - 1;
    const maxX = Math.floor((r.x + r.w) / TILE) + 1;
    const minY = Math.floor(r.y / TILE) - 1;
    const maxY = Math.floor((r.y + r.h) / TILE) + 1;
    const solids = [];
    for (let ty=minY; ty<=maxY; ty++){
      for (let tx=minX; tx<=maxX; tx++){
        if (tileSolid(tx,ty)){
          solids.push({x:tx*TILE, y:ty*TILE, w:TILE, h:TILE, tx, ty});
        }
      }
    }
    return solids;
  }

  function rectHitsSpikes(r){
    const minX = Math.floor(r.x / TILE) - 1;
    const maxX = Math.floor((r.x + r.w) / TILE) + 1;
    const minY = Math.floor(r.y / TILE) - 1;
    const maxY = Math.floor((r.y + r.h) / TILE) + 1;
    for (let ty=minY; ty<=maxY; ty++){
      for (let tx=minX; tx<=maxX; tx++){
        if (tileSpike(tx,ty)){
          const s = {x:tx*TILE, y:ty*TILE, w:TILE, h:TILE};
          if (rectsOverlap(r,s)) return true;
        }
      }
    }
    return false;
  }

  // ----- Player
  const player = {
    x: 2*TILE + 6,
    y: 2*TILE,
    w: TILE-12,
    h: TILE-10,
    vx: 0,
    vy: 0,
    grounded: false,
    face: 1,
    coyote: 0,
    jumpBuf: 0,
    onShrine: 0
  };

  let checkpoint = {x: player.x, y: player.y, id: 1};
  let deaths = 0;
  let tokens = 0;
  let complaint = 0; // 0..1
  let runStart = now();
  let gameState = 'menu'; // menu | play | win
  let lastTick = now();

  // ----- Doors, plates, levers logic
  function doorByIndex(i){
    return doors[clamp(i,0,doors.length-1)];
  }
  function isPlatePressed(p){
    const plateRect = {x:p.tx*TILE+6, y:p.ty*TILE+20, w:TILE-12, h:10};
    // player feet
    const feet = {x:player.x+2, y:player.y+player.h-6, w:player.w-4, h:8};
    if (rectsOverlap(feet, plateRect)) return true;
    for (const c of crates){
      const cr = {x:c.x, y:c.y, w:c.w, h:c.h};
      if (rectsOverlap(cr, plateRect)) return true;
    }
    return false;
  }

  function tryActivateShrine(){
    // if near shrine, set checkpoint + reduce complaint a bit
    for (const s of shrines){
      const sr = {x:s.tx*TILE, y:s.ty*TILE, w:TILE, h:TILE};
      const pr = {x:player.x, y:player.y, w:player.w, h:player.h};
      if (rectsOverlap(pr, sr)){
        checkpoint = {x:s.tx*TILE+6, y:s.ty*TILE-4, id: (shrines.indexOf(s)+1)};
        elCP.textContent = checkpoint.id;
        complaint = Math.max(0, complaint - 0.18);
        spawnSpark(sr.x+TILE/2, sr.y+TILE/2, 16);
        chord(220 + checkpoint.id*20);
        VIBE.say("Aight, paladin... you hit the shrine. The Karen God calmin’ down... for now.", true);
        return true;
      }
    }
    return false;
  }

  function tryFlipLever(){
    for (const l of levers){
      const lr = {x:l.tx*TILE, y:l.ty*TILE, w:TILE, h:TILE};
      const pr = {x:player.x, y:player.y, w:player.w, h:player.h};
      // interact radius
      const near = {
        x: pr.x - 12, y: pr.y - 8,
        w: pr.w + 24, h: pr.h + 16
      };
      if (rectsOverlap(near, lr)){
        const d = doorByIndex(l.doorIndex);
        if (!d) return false;
        l.state = !l.state;
        if (l.timed){
          d.open = true;
          d.tmr = l.duration;
          VIBE.say("Flip that lever, yo. Door open... but it’s on a timer. Hustle smooth.", true);
        }else{
          d.open = !d.open;
          VIBE.say("Lever flipped. Door vibes changed. Bureaucracy got switches too.", true);
        }
        spawnSpark(lr.x+TILE/2, lr.y+TILE/2, 10, [255,210,74],[255,77,125]);
        beep(520,0.06,'triangle',0.06);
        return true;
      }
    }
    return false;
  }

  function collectItems(){
    const pr = {x:player.x, y:player.y, w:player.w, h:player.h};
    for (const it of items){
      if (it.taken) continue;
      const ir = {x:it.x-10, y:it.y-10, w:20, h:20};
      if (rectsOverlap(pr, ir)){
        it.taken = true;
        if (it.kind === 'coupon'){
          complaint = Math.max(0, complaint - 0.28);
          spawnSpark(it.x, it.y, 14, [79,226,255],[67,255,182]);
          beep(740,0.05,'sine',0.07);
          VIBE.say("Coupon acquired. The Karen God loves discounts more than mercy.", false, 2400);
        }else if (it.kind === 'token'){
          tokens++;
          elTokens.textContent = tokens;
          spawnSpark(it.x, it.y, 18, [184,107,255],[79,226,255]);
          chord(260 + tokens*60);
          VIBE.say(`Manager Token secured (${tokens}/3). You one step closer to speakin’ to the mythical manager.`, true);
        }
      }
    }
  }

  function updateDoors(dt){
    // plates keep doors open while pressed
    for (const p of plates){
      const d = doorByIndex(p.doorIndex);
      if (!d) continue;
      if (isPlatePressed(p)){
        d.open = true;
        d.tmr = Math.max(d.tmr, 0.18); // small grace so it doesn't flicker
      }
    }
    // lever timers
    for (const d of doors){
      if (d.tmr > 0){
        d.tmr -= dt;
        if (d.tmr <= 0){
          d.tmr = 0;
          // if no plate currently holding it, close
          let held = false;
          for (const p of plates){
            if (p.doorIndex === doors.indexOf(d) && isPlatePressed(p)){ held = true; break; }
          }
          if (!held) d.open = false;
          if (!d.open){
            sizzle();
            spawnDust(d.tx*TILE+TILE/2, d.ty*TILE+TILE/2, 10);
          }
        }
      }else{
        // if not held by plate and not explicitly opened, ensure closed unless plate says otherwise
        let held = false;
        for (const p of plates){
          if (p.doorIndex === doors.indexOf(d) && isPlatePressed(p)){ held = true; break; }
        }
        if (!held) d.open = false;
      }
    }
  }

  // ----- Movement / physics
  const GRAV = 1700;
  const MOVE = 920;
  const AIR = 0.55;
  const FRICTION = 0.82;
  const JUMP = 640;

  function stepEntity(ent, dt, canPush=true){
    ent.vy += GRAV * dt;
    // Clamp velocities
    ent.vx = clamp(ent.vx, -650, 650);
    ent.vy = clamp(ent.vy, -9999, 1100);

    // Horizontal move
    ent.x += ent.vx * dt;
    let solids = rectCollideWithWorld(ent);
    for (const s of solids){
      if (rectsOverlap(ent, s)){
        if (ent.vx > 0){
          ent.x = s.x - ent.w;
        }else if (ent.vx < 0){
          ent.x = s.x + s.w;
        }
        ent.vx = 0;
      }
    }

    // Vertical move
    ent.y += ent.vy * dt;
    ent.grounded = false;
    solids = rectCollideWithWorld(ent);
    for (const s of solids){
      if (rectsOverlap(ent, s)){
        if (ent.vy > 0){
          ent.y = s.y - ent.h;
          ent.vy = 0;
          ent.grounded = true;
        }else if (ent.vy < 0){
          ent.y = s.y + s.h;
          ent.vy = 0;
        }
      }
    }

    // World bounds
    ent.x = clamp(ent.x, 0, WORLD_W - ent.w);
    ent.y = clamp(ent.y, -200, WORLD_H - ent.h);
  }

  function resolvePlayerCrate(dt){
    // Simple pushing: if player overlaps crate horizontally, push crate
    const pr = {x:player.x, y:player.y, w:player.w, h:player.h};
    for (const c of crates){
      const cr = {x:c.x, y:c.y, w:c.w, h:c.h};
      if (rectsOverlap(pr, cr)){
        // determine minimal separation
        const dx1 = (pr.x+pr.w) - cr.x;
        const dx2 = (cr.x+cr.w) - pr.x;
        const dy1 = (pr.y+pr.h) - cr.y;
        const dy2 = (cr.y+cr.h) - pr.y;
        const minX = Math.min(dx1, dx2);
        const minY = Math.min(dy1, dy2);

        if (minX < minY){
          // separate in X
          if (dx1 < dx2){
            // player from left
            player.x -= dx1;
            c.vx = Math.max(c.vx, player.vx*0.65);
          }else{
            // player from right
            player.x += dx2;
            c.vx = Math.min(c.vx, player.vx*0.65);
          }
          thud();
        }else{
          // separate in Y
          if (dy1 < dy2){
            player.y -= dy1;
            player.vy = 0;
            player.grounded = true;
          }else{
            player.y += dy2;
            player.vy = 0;
          }
        }
      }
    }
  }

  // ----- Respawn / hazard
  function respawn(reason="spikes"){
    deaths++;
    elDeaths.textContent = deaths;
    player.x = checkpoint.x;
    player.y = checkpoint.y;
    player.vx = 0;
    player.vy = 0;
    complaint = Math.min(0.85, complaint + 0.18);
    spawnDust(player.x+player.w/2, player.y+player.h/2, 18);
    beep(180,0.08,'sawtooth',0.07);
    if (reason === "spikes"){
      VIBE.say("Ooo—spikes. That’s not customer-service friendly. Back to the checkpoint, playa.", true);
    }else{
      VIBE.say("Complaint meter maxed. Karen God said: 'Start over from the last checkpoint.'", true);
    }
  }

  // ----- Win check
  function checkWin(){
    const pr = {x:player.x, y:player.y, w:player.w, h:player.h};
    const er = {x:exitPos.x-18, y:exitPos.y-18, w:36, h:36};
    if (rectsOverlap(pr, er)){
      if (tokens >= 3){
        gameState = 'win';
        spawnSpark(exitPos.x, exitPos.y, 42, [255,210,74],[67,255,182]);
        chord(330);
        chord(440);
        VIBE.say("Ayyyy! You reached the Service Desk with all three tokens. Manager summoned. Victory, my paladin.", true, 3800);
      }else{
        VIBE.say(`Service Desk locked. You need ${3-tokens} more Manager Token(s). Go handle that paperwork.`, false, 2600);
      }
    }
  }

  // ----- UI overlay buttons
  function showOverlay(show=true){
    overlay.classList.toggle('show', show);
  }
  btnHelp.addEventListener('click', () => showOverlay(true));
  btnClose.addEventListener('click', () => showOverlay(false));
  btnPlay.addEventListener('click', () => { showOverlay(false); if (gameState==='menu') startGame(); });
  btnRestart.addEventListener('click', () => hardRestart());
  btnSound.addEventListener('click', () => toggleSound());
  function toggleSound(){
    audioOn = !audioOn;
    soundState.textContent = audioOn ? "ON" : "OFF";
    if (audioOn) beep(660,0.06,'sine',0.06);
  }

  // ----- Game start/restart
  function hardRestart(){
    // reset all dynamic state
    tokens = 0;
    elTokens.textContent = tokens;
    complaint = 0;
    deaths = 0;
    elDeaths.textContent = deaths;
    runStart = now();

    // reset doors, levers
    doors.forEach(d=>{d.open=false; d.tmr=0;});
    levers.forEach(l=>{l.state=false;});
    // reset items
    items.forEach(it=>it.taken=false);

    // reset crates to original spawns (re-parse B positions by scanning original level)
    crates.length = 0;
    for (let y=0;y<level.length;y++){
      for (let x=0;x<level[0].length;x++){
        if (level[y][x] === 'B'){
          crates.push({x:x*TILE+6, y:y*TILE+6, w:TILE-12, h:TILE-12, vx:0, vy:0, grounded:false});
        }
      }
    }

    // player to first shrine if exists, else spawn near left
    const s0 = shrines[0] || {tx:2, ty:2};
    player.x = s0.tx*TILE+6;
    player.y = s0.ty*TILE-4;
    player.vx = 0;
    player.vy = 0;
    checkpoint = {x:player.x, y:player.y, id:1};
    elCP.textContent = checkpoint.id;

    gameState = 'play';
    banner.classList.remove('show');
    VIBE.say("Welcome back, paladin. Your god’s a Karen. So uh… be polite, be quick, and don’t step on spikes.", true, 3600);
    beep(520,0.05,'triangle',0.06);
  }

  function startGame(){
    hardRestart();
  }

  // ----- Menu banner
  function showBanner(){
    banner.classList.add('show');
    setTimeout(()=>banner.classList.remove('show'), 2200);
  }

  // ----- Time formatting
  function fmtTime(ms){
    const s = Math.max(0, Math.floor(ms/1000));
    const m = Math.floor(s/60);
    const r = s%60;
    return `${m}:${String(r).padStart(2,'0')}`;
  }

  // ----- Draw helpers
  function setScale(){
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }

  function drawRoundedRect(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // ----- Camera
  const cam = {x:0,y:0, shake:0};
  function updateCam(dt){
    const targetX = player.x + player.w/2 - (innerWidth/2);
    const targetY = player.y + player.h/2 - (innerHeight/2);
    cam.x = lerp(cam.x, clamp(targetX, 0, WORLD_W - innerWidth), 1 - Math.pow(0.000001, dt));
    cam.y = lerp(cam.y, clamp(targetY, 0, WORLD_H - innerHeight), 1 - Math.pow(0.000001, dt));
    if (cam.shake > 0) cam.shake = Math.max(0, cam.shake - dt*2.8);
  }

  // ----- Render world
  function drawWorld(dt){
    // background
    ctx.fillStyle = '#07070b';
    ctx.fillRect(0,0,innerWidth,innerHeight);

    const t = now()*0.001;
    // faux-nebula
    ctx.globalAlpha = 0.18;
    for (let i=0;i<6;i++){
      const x = (Math.sin(t*0.3+i*1.7)*0.5+0.5)*innerWidth;
      const y = (Math.cos(t*0.25+i*1.2)*0.5+0.5)*innerHeight;
      const r = 120 + (Math.sin(t*0.6+i)*0.5+0.5)*220;
      const g = ctx.createRadialGradient(x,y,0,x,y,r);
      g.addColorStop(0, `rgba(184,107,255,${0.22})`);
      g.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // camera transform
    const shakeX = (Math.random()*2-1) * 10 * cam.shake;
    const shakeY = (Math.random()*2-1) * 10 * cam.shake;
    ctx.save();
    ctx.translate(-cam.x + shakeX, -cam.y + shakeY);

    // draw tiles (only visible)
    const minTX = Math.floor(cam.x / TILE) - 2;
    const maxTX = Math.floor((cam.x + innerWidth) / TILE) + 2;
    const minTY = Math.floor(cam.y / TILE) - 2;
    const maxTY = Math.floor((cam.y + innerHeight) / TILE) + 2;

    // floor glow grid
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = 'rgba(79,226,255,.35)';
    ctx.lineWidth = 1;
    for (let x=minTX*TILE; x<=(maxTX+1)*TILE; x+=TILE){
      ctx.beginPath();
      ctx.moveTo(x, minTY*TILE);
      ctx.lineTo(x, (maxTY+1)*TILE);
      ctx.stroke();
    }
    for (let y=minTY*TILE; y<=(maxTY+1)*TILE; y+=TILE){
      ctx.beginPath();
      ctx.moveTo(minTX*TILE, y);
      ctx.lineTo((maxTX+1)*TILE, y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // walls
    for (let ty=minTY; ty<=maxTY; ty++){
      for (let tx=minTX; tx<=maxTX; tx++){
        const ch = tileAt(tx,ty);
        if (ch === '#'){
          const x=tx*TILE, y=ty*TILE;
          // beveled block
          const grd = ctx.createLinearGradient(x,y,x,y+TILE);
          grd.addColorStop(0,'#11133a');
          grd.addColorStop(1,'#090a18');
          ctx.fillStyle = grd;
          ctx.fillRect(x,y,TILE,TILE);

          ctx.strokeStyle = 'rgba(255,255,255,.08)';
          ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);

          // inner rune
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = 'rgba(184,107,255,.5)';
          ctx.fillRect(x+TILE*0.18, y+TILE*0.2, TILE*0.12, TILE*0.6);
          ctx.globalAlpha = 1;
        } else if (ch === '^'){
          const x=tx*TILE, y=ty*TILE;
          ctx.fillStyle = '#0b0b14';
          ctx.fillRect(x,y,TILE,TILE);
          ctx.fillStyle = 'rgba(255,77,125,.85)';
          ctx.beginPath();
          for (let i=0;i<4;i++){
            const px = x + i*(TILE/4);
            ctx.moveTo(px+2, y+TILE);
            ctx.lineTo(px+TILE/8, y+TILE*0.2);
            ctx.lineTo(px+TILE/4-2, y+TILE);
          }
          ctx.fill();
        } else if (ch === 'D'){
          const d = doors.find(dd=>dd.tx===tx && dd.ty===ty);
          const x=tx*TILE, y=ty*TILE;
          if (d && d.open){
            // open shimmer
            ctx.globalAlpha = 0.22;
            const g = ctx.createLinearGradient(x,y,x+TILE,y+TILE);
            g.addColorStop(0,'rgba(79,226,255,.55)');
            g.addColorStop(1,'rgba(184,107,255,.15)');
            ctx.fillStyle = g;
            ctx.fillRect(x,y,TILE,TILE);
            ctx.globalAlpha = 1;
          }else{
            // closed door
            const grd = ctx.createLinearGradient(x,y,x,y+TILE);
            grd.addColorStop(0,'#2a1540');
            grd.addColorStop(1,'#140a1f');
            ctx.fillStyle = grd;
            ctx.fillRect(x,y,TILE,TILE);
            ctx.strokeStyle = 'rgba(255,255,255,.12)';
            ctx.strokeRect(x+1,y+1,TILE-2,TILE-2);
            // lock sigil
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = 'rgba(255,210,74,.9)';
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2+4, 6, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        } else if (ch === 'P'){
          const x=tx*TILE, y=ty*TILE;
          const pressedNow = isPlatePressed(plates.find(p=>p.tx===tx && p.ty===ty) || {tx,ty,doorIndex:0});
          ctx.fillStyle = pressedNow ? 'rgba(67,255,182,.75)' : 'rgba(255,210,74,.65)';
          ctx.fillRect(x+6,y+TILE-12,TILE-12,8);
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = 'rgba(255,255,255,.9)';
          ctx.fillRect(x+10,y+TILE-10,TILE-20,2);
          ctx.globalAlpha = 1;
        } else if (ch === 'L'){
          const x=tx*TILE, y=ty*TILE;
          ctx.fillStyle = 'rgba(79,226,255,.22)';
          ctx.fillRect(x+8,y+8,TILE-16,TILE-16);
          ctx.strokeStyle = 'rgba(255,255,255,.12)';
          ctx.strokeRect(x+8.5,y+8.5,TILE-17,TILE-17);
          // handle
          ctx.save();
          ctx.translate(x+TILE/2, y+TILE/2);
          ctx.rotate(Math.sin(t*2)*0.08);
          ctx.fillStyle = 'rgba(255,210,74,.9)';
          ctx.fillRect(-2,-10,4,20);
          ctx.restore();
        } else if (ch === 'S'){
          const x=tx*TILE, y=ty*TILE;
          // shrine pad
          const g = ctx.createRadialGradient(x+TILE/2,y+TILE/2,2,x+TILE/2,y+TILE/2,18);
          g.addColorStop(0,'rgba(79,226,255,.65)');
          g.addColorStop(1,'rgba(184,107,255,.05)');
          ctx.fillStyle = g;
          ctx.fillRect(x,y,TILE,TILE);
          // candle pixels
          ctx.fillStyle = 'rgba(255,210,74,.85)';
          ctx.fillRect(x+14,y+10,4,10);
          ctx.globalAlpha = 0.6;
          ctx.fillStyle = 'rgba(255,77,125,.9)';
          ctx.fillRect(x+15,y+8,2,2);
          ctx.globalAlpha = 1;
        }
      }
    }

    // draw items
    for (const it of items){
      if (it.taken) continue;
      const bob = Math.sin(t*2 + it.bob)*3;
      ctx.save();
      ctx.translate(it.x, it.y + bob);
      if (it.kind === 'coupon'){
        // coupon ticket
        ctx.fillStyle = 'rgba(67,255,182,.85)';
        drawRoundedRect(-11,-7,22,14,4);
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,.35)';
        ctx.stroke();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = 'rgba(0,0,0,.35)';
        ctx.fillRect(-7,-2,14,2);
        ctx.fillRect(-7, 2,10,2);
        ctx.globalAlpha = 1;
      }else{
        // token
        const g = ctx.createRadialGradient(0,0,1,0,0,12);
        g.addColorStop(0,'rgba(255,210,74,.95)');
        g.addColorStop(1,'rgba(184,107,255,.25)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0,0,10,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,.18)';
        ctx.beginPath();
        ctx.arc(0,0,10,0,Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }

    // draw crates
    for (const c of crates){
      const x=c.x, y=c.y;
      const g = ctx.createLinearGradient(x,y,x,y+c.h);
      g.addColorStop(0,'#2a2c44');
      g.addColorStop(1,'#15162a');
      ctx.fillStyle = g;
      drawRoundedRect(x,y,c.w,c.h,8);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.12)';
      ctx.stroke();

      // sticker: "MANAGER?"
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = 'rgba(255,210,74,.85)';
      drawRoundedRect(x+6,y+6,c.w-12,12,6);
      ctx.fill();
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(x+10,y+10, Math.max(10,c.w-20), 2);
      ctx.globalAlpha = 1;
    }

    // draw exit / service desk
    {
      const x = exitPos.tx*TILE, y = exitPos.ty*TILE;
      const g = ctx.createLinearGradient(x,y,x,y+TILE);
      g.addColorStop(0,'rgba(255,255,255,.10)');
      g.addColorStop(1,'rgba(255,255,255,.02)');
      ctx.fillStyle = g;
      drawRoundedRect(x+3,y+3,TILE-6,TILE-6,10);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.14)';
      ctx.stroke();

      // sign
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(255,210,74,.85)';
      drawRoundedRect(x-10,y-18,TILE+20,14,8);
      ctx.fill();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.fillRect(x-4,y-12,TILE+8,2);
      ctx.globalAlpha = 1;

      // glow if ready
      if (tokens>=3){
        ctx.globalAlpha = 0.25 + 0.12*Math.sin(t*4);
        const rg = ctx.createRadialGradient(x+TILE/2,y+TILE/2,1,x+TILE/2,y+TILE/2,40);
        rg.addColorStop(0,'rgba(67,255,182,.75)');
        rg.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle = rg;
        ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,40,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // draw player
    {
      const x=player.x, y=player.y;
      // aura
      ctx.globalAlpha = 0.22;
      const a = ctx.createRadialGradient(x+player.w/2,y+player.h/2,4,x+player.w/2,y+player.h/2,40);
      a.addColorStop(0,'rgba(79,226,255,.6)');
      a.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = a;
      ctx.beginPath();
      ctx.arc(x+player.w/2,y+player.h/2,40,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // body
      const g = ctx.createLinearGradient(x,y,x,y+player.h);
      g.addColorStop(0,'#dfe6ff');
      g.addColorStop(1,'#94a2ff');
      ctx.fillStyle = g;
      drawRoundedRect(x,y,player.w,player.h,10);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,.28)';
      ctx.stroke();

      // visor cross
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = 'rgba(0,0,0,.28)';
      ctx.fillRect(x+player.w/2-1, y+6, 2, player.h-12);
      ctx.fillRect(x+6, y+player.h/2-1, player.w-12, 2);
      ctx.globalAlpha = 1;

      // cape flick
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = 'rgba(184,107,255,.75)';
      const fx = x + (player.face>0 ? -10 : player.w+2);
      const sway = Math.sin(t*6 + x*0.02)*6;
      drawRoundedRect(fx, y+6+sway*0.2, 12, player.h-10, 10);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // particles
    for (let i=parts.length-1;i>=0;i--){
      const p = parts[i];
      p.age += dt;
      if (p.age >= p.life){ parts.splice(i,1); continue; }
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= Math.pow(0.001, dt); // drag
      p.vy += 780*dt;

      const a = 1 - (p.age/p.life);
      ctx.globalAlpha = a;
      ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${a})`;
      ctx.fillRect(p.x - p.s/2, p.y - p.s/2, p.s, p.s);
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // vignette
    ctx.globalAlpha = 0.55;
    const vg = ctx.createRadialGradient(innerWidth/2, innerHeight/2, Math.min(innerWidth,innerHeight)*0.15, innerWidth/2, innerHeight/2, Math.max(innerWidth,innerHeight)*0.7);
    vg.addColorStop(0,'rgba(0,0,0,0)');
    vg.addColorStop(1,'rgba(0,0,0,.65)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,innerWidth,innerHeight);
    ctx.globalAlpha = 1;

    // win screen overlay
    if (gameState==='win'){
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.fillRect(0,0,innerWidth,innerHeight);
      ctx.globalAlpha = 1;

      const w = Math.min(720, innerWidth-40);
      const h = 250;
      const x = (innerWidth - w)/2;
      const y = (innerHeight - h)/2;

      const gg = ctx.createLinearGradient(x,y,x,y+h);
      gg.addColorStop(0,'rgba(255,255,255,.11)');
      gg.addColorStop(1,'rgba(255,255,255,.04)');
      ctx.fillStyle = gg;
      drawRoundedRect(x,y,w,h,22);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.18)';
      ctx.stroke();

      ctx.fillStyle = 'rgba(233,236,255,.95)';
      ctx.font = '900 20px ui-sans-serif, system-ui';
      ctx.fillText('YOU WON: Manager Summoned ✅', x+18, y+44);

      ctx.fillStyle = 'rgba(174,182,255,.95)';
      ctx.font = '600 14px ui-sans-serif, system-ui';
      ctx.fillText(`Time: ${fmtTime(now()-runStart)}   •   Deaths: ${deaths}   •   Complaint Meter: ${Math.round(complaint*100)}%`, x+18, y+74);

      ctx.fillStyle = 'rgba(233,236,255,.9)';
      ctx.font = '700 14px ui-sans-serif, system-ui';
      ctx.fillText('Press R to restart a fresh run. Press H for the overlay.', x+18, y+h-26);

      // fireworks
      if (Math.random()<0.15){
        spawnSpark(innerWidth*0.3 + rand(innerWidth*0.4), innerHeight*0.25 + rand(innerHeight*0.3), 10, [255,210,74],[79,226,255]);
        if (Math.random()<0.5) beep(660+rand(220), 0.03, 'triangle', 0.03);
      }
    }
  }

  // ----- Simulation tick
  function tick(){
    const t = now();
    const dt = clamp((t - lastTick)/1000, 0, 1/30);
    lastTick = t;

    setScale();

    // global hotkeys
    if (pressed.has('h')) { showOverlay(!overlay.classList.contains('show')); }
    if (pressed.has('m')) { toggleSound(); }
    if (pressed.has('r')) { hardRestart(); }
    if (pressed.has('enter') && gameState==='menu'){ startGame(); showOverlay(false); }

    if (gameState === 'menu'){
      // little animation and banner
      drawWorld(dt);
      if (!banner.classList.contains('show')) showBanner();
      // show overlay on first load
      if (!overlay.classList.contains('show')) showOverlay(true);
      narrator.tick();
      pressed.clear();
      requestAnimationFrame(tick);
      return;
    }

    // Update time UI
    elTime.textContent = fmtTime(t - runStart);

    // Complaint meter behavior:
    // rises slowly, rises faster if idling; decreases by coupons/shrines.
    // If maxed: respawn at checkpoint (not game over).
    const moving = Math.abs(player.vx) + Math.abs(player.vy) > 40;
    complaint += dt * (moving ? 0.032 : 0.052);
    complaint = clamp(complaint, 0, 1);

    if (complaint >= 1){
      cam.shake = 1;
      respawn("complaint");
      complaint = 0.55;
    }

    // Player control
    const left = keys.has('arrowleft') || keys.has('a');
    const right = keys.has('arrowright') || keys.has('d');
    const jump = keys.has('arrowup') || keys.has('w') || keys.has(' ');
    const interact = pressed.has('e');

    const accel = MOVE * dt * (player.grounded ? 1 : AIR);
    if (left){
      player.vx -= accel;
      player.face = -1;
    }
    if (right){
      player.vx += accel;
      player.face = 1;
    }
    if (!left && !right){
      // friction
      player.vx *= Math.pow(FRICTION, dt*60);
      if (Math.abs(player.vx) < 6) player.vx = 0;
    }

    // coyote time and jump buffer
    if (player.grounded) player.coyote = 0.12;
    else player.coyote = Math.max(0, player.coyote - dt);

    if (jump) player.jumpBuf = 0.12;
    else player.jumpBuf = Math.max(0, player.jumpBuf - dt);

    if (player.jumpBuf > 0 && player.coyote > 0){
      player.vy = -JUMP;
      player.grounded = false;
      player.coyote = 0;
      player.jumpBuf = 0;
      spawnDust(player.x+player.w/2, player.y+player.h, 10);
      beep(420,0.05,'triangle',0.06);
    }

    // Interactions
    if (interact){
      const didLever = tryFlipLever();
      const didShrine = tryActivateShrine();
      if (!didLever && !didShrine){
        VIBE.say("E pressed… but ain’t nothin’ to interact with. Find a lever or shrine, my paladin.", false, 2000);
        beep(240,0.04,'sine',0.03);
      }
    }

    // Crates: basic physics
    for (const c of crates){
      // mild friction
      if (c.grounded) c.vx *= Math.pow(0.86, dt*60);
      if (Math.abs(c.vx) < 3) c.vx = 0;
      stepEntity(c, dt, false);
    }

    // Doors logic
    updateDoors(dt);

    // Apply door states to tile map (so collision sees them)
    // Place 'D' in grid always for location; collision checks door open state.
    // (Grid already contains 'D' for doors from parse.)
    for (const d of doors){
      setTile(d.tx, d.ty, 'D');
    }

    // Player physics step
    stepEntity(player, dt, true);

    // Push crates if colliding
    resolvePlayerCrate(dt);

    // Hazards
    if (rectHitsSpikes({x:player.x,y:player.y,w:player.w,h:player.h})){
      cam.shake = 0.9;
      respawn("spikes");
    }

    // Collect
    collectItems();

    // Shrines auto-set checkpoint when standing on them (gentle)
    for (const s of shrines){
      const sr = {x:s.tx*TILE, y:s.ty*TILE, w:TILE, h:TILE};
      const pr = {x:player.x, y:player.y, w:player.w, h:player.h};
      if (rectsOverlap(pr, sr)){
        // soft update only if different
        const id = shrines.indexOf(s)+1;
        if (checkpoint.id !== id){
          checkpoint = {x:s.tx*TILE+6, y:s.ty*TILE-4, id};
          elCP.textContent = checkpoint.id;
          spawnSpark(sr.x+TILE/2, sr.y+TILE/2, 10);
          beep(600,0.04,'triangle',0.04);
          VIBE.say("Checkpoint updated. Karen God logged the ticket number.", false, 2400);
        }
      }
    }

    // Win condition
    checkWin();

    // Camera
    updateCam(dt);

    // UI
    elComplaintFill.style.width = `${Math.round(complaint*100)}%`;

    // Draw
    drawWorld(dt);

    // Narrator tick
    narrator.tick();

    // Suggestion toast occasionally
    if (Math.random() < 0.004 && gameState==='play' && narrator.queue.length===0){
      const tips = [
        "Pro tip: crates go on plates. Plates open doors. Doors keep your drip intact.",
        "Coupons ain’t just paper, homie — they’re holy offerings.",
        "Levers open doors on a timer. Move like you got somewhere to be (you do).",
        "If you hear spikes callin’, don’t answer that phone.",
        "Shrines = checkpoint. Touch ‘em like you mean it."
      ];
      VIBE.say(tips[randi(tips.length)], false, 2400);
    }

    pressed.clear();
    requestAnimationFrame(tick);
  }

  // ----- Click-to-focus + start audio
  addEventListener('pointerdown', () => {
    if (audioOn) ensureAudio();
  });

  // ----- Intro
  showBanner();
  VIBE.say("Yo… you’re a paladin… and your god? A Karen. Let’s handle these puzzles with customer-service elegance.", true, 3600);

  // Start loop
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>