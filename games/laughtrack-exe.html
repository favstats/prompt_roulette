<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SITCOM SIMULATOR (OFFLINE) v1.1</title>
  <style>
    :root{
      --bg:#050505;
      --neon:#32ff32;
      --dark:#146414;
      --alert:#ff3232;
      --panel:rgba(0,0,0,.65);
      --line:rgba(50,255,50,.18);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      overflow:hidden;
      height:100vh;
      display:grid;
      place-items:center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color:var(--neon);
    }

    /* CRT overlay */
    #crt-overlay{
      position:fixed; inset:0;
      pointer-events:none;
      z-index:10;
      background:
        linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.25) 50%),
        linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
      background-size: 100% 2px, 3px 100%;
      mix-blend-mode: screen;
      opacity:.9;
      filter: saturate(1.05);
    }
    #vignette{
      position:fixed; inset:0;
      pointer-events:none;
      z-index:9;
      background: radial-gradient(circle at center, rgba(0,0,0,0) 0%, rgba(0,0,0,.55) 70%, rgba(0,0,0,.85) 100%);
    }

    .wrap{
      position:relative;
      width:min(92vw, 860px);
      aspect-ratio: 4 / 3;
      display:grid;
      place-items:center;
    }

    canvas{
      width:100%;
      height:100%;
      border:2px solid #333;
      box-shadow: 0 0 60px rgba(50,255,50,.18);
      image-rendering: pixelated;
      background: rgb(10,25,10);
    }

    /* HUD + controls */
    .hud{
      position:absolute;
      inset: 10px 10px auto 10px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      pointer-events:none;
      z-index:4;
    }
    .hud .left, .hud .right{
      display:flex;
      flex-direction:column;
      gap:6px;
      pointer-events:none;
    }
    .chip{
      pointer-events:none;
      padding:6px 10px;
      border:1px solid rgba(50,255,50,.25);
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      border-radius:10px;
      font-size:14px;
      line-height:1.1;
      letter-spacing:.2px;
      text-shadow: 0 0 10px rgba(50,255,50,.25);
    }
    .chip.alert{
      border-color: rgba(255,50,50,.35);
      color: var(--alert);
      text-shadow: 0 0 10px rgba(255,50,50,.25);
    }
    .centerbar{
      position:absolute;
      left:50%;
      top:12px;
      transform:translateX(-50%);
      display:flex;
      gap:8px;
      z-index:4;
      pointer-events:none;
      opacity:.95;
    }
    .hint{
      pointer-events:none;
      padding:6px 10px;
      border:1px solid rgba(20,100,20,.45);
      background: rgba(0,0,0,.25);
      border-radius:10px;
      font-size:13px;
      color: rgba(50,255,50,.75);
    }

    /* Overlay */
    .overlay{
      position:absolute;
      inset:0;
      display:none;
      z-index:6;
      align-items:center;
      justify-content:center;
      padding:16px;
    }
    .overlay.show{ display:flex; }
    .panel{
      width:min(720px, 95%);
      background: var(--panel);
      border:1px solid rgba(50,255,50,.25);
      border-radius:16px;
      padding:18px 16px;
      box-shadow: 0 0 30px rgba(0,0,0,.5);
    }
    .panel h1{
      margin:0 0 8px 0;
      font-size:22px;
      letter-spacing:.6px;
    }
    .panel p{
      margin:10px 0;
      color: rgba(50,255,50,.85);
      font-size:14px;
      line-height:1.5;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    .kbd{
      display:inline-block;
      padding:2px 6px;
      border:1px solid rgba(50,255,50,.25);
      border-bottom-color: rgba(50,255,50,.4);
      border-radius:8px;
      background: rgba(0,0,0,.3);
      font-size:12px;
      color: rgba(50,255,50,.9);
      margin:0 3px;
    }
    .btnrow{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      margin-top:14px;
    }
    button{
      pointer-events:auto;
      border:1px solid rgba(50,255,50,.35);
      background: rgba(0,0,0,.35);
      color: var(--neon);
      border-radius:12px;
      padding:10px 12px;
      font: inherit;
      font-size:14px;
      cursor:pointer;
      transition: transform .08s ease, background .08s ease, border-color .08s ease;
      outline:none;
    }
    button:hover{ transform: translateY(-1px); background: rgba(0,0,0,.5); }
    button:active{ transform: translateY(0px); }
    button:focus-visible{
      box-shadow: 0 0 0 3px rgba(50,255,50,.18);
    }
    .danger{
      border-color: rgba(255,50,50,.45);
      color: var(--alert);
    }

    /* Bottom micro HUD */
    .bottom{
      position:absolute;
      left:50%;
      bottom:12px;
      transform:translateX(-50%);
      display:flex;
      gap:10px;
      z-index:4;
      pointer-events:none;
      opacity:.95;
      flex-wrap:wrap;
      justify-content:center;
    }

    /* Tiny “glitch” animation */
    @keyframes glitch {
      0%{ transform:translate(0,0) }
      20%{ transform:translate(-1px,0) }
      40%{ transform:translate(1px,0) }
      60%{ transform:translate(-1px,1px) }
      80%{ transform:translate(1px,-1px) }
      100%{ transform:translate(0,0) }
    }
    .glitchy{ animation: glitch .18s infinite; }

    /* Accessibility helpers */
    .sr-only{
      position:absolute; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); border:0;
    }
  </style>
</head>
<body>
  <div id="vignette"></div>
  <div id="crt-overlay"></div>

  <div class="wrap" role="application" aria-label="Sitcom Simulator game">
    <canvas id="game" width="800" height="600" tabindex="0" aria-label="Game canvas"></canvas>

    <div class="hud" aria-hidden="true">
      <div class="left">
        <div id="batteryChip" class="chip">BATTERY: 100%</div>
        <div id="statusChip" class="chip" style="opacity:.85">STATUS: READY</div>
      </div>
      <div class="right">
        <div id="humanChip" class="chip">HUMANITY: 0%</div>
        <div id="soundChip" class="chip" style="opacity:.85">SOUND: ON (M)</div>
      </div>
    </div>

    <div class="centerbar" aria-hidden="true">
      <div class="hint">MISSION: ABSORB HUMAN HUMOR</div>
      <div class="hint">GOAL: HUMANITY 100%</div>
    </div>

    <div class="bottom" aria-hidden="true">
      <div id="shopChip" class="hint">[1] SIZE (-15%) · [2] SLOW (-10%) · [3] MULTI (-20%)</div>
      <div class="hint">MOVE: ↑/↓ or W/S · HELP: H · RESTART: R</div>
    </div>

    <!-- How to Play -->
    <div id="howOverlay" class="overlay" role="dialog" aria-modal="true" aria-label="How to play">
      <div class="panel">
        <h1>HOW TO PLAY</h1>
        <p>
          You are a robot trapped in a TV studio. Bounce the “humor signal” past the Network to gain
          <b>HUMANITY</b>. Every time you miss, you lose <b>BATTERY</b>.
        </p>
        <div class="grid">
          <p>
            <b>Move</b>: <span class="kbd">↑</span><span class="kbd">↓</span> or <span class="kbd">W</span><span class="kbd">S</span><br/>
            <b>Restart</b>: <span class="kbd">R</span><br/>
            <b>Toggle sound</b>: <span class="kbd">M</span>
          </p>
          <p>
            <b>Battery is currency.</b><br/>
            <span class="kbd">1</span> Big Paddle (8s) −15%<br/>
            <span class="kbd">2</span> Slow Time (2s) −10%<br/>
            <span class="kbd">3</span> Multiball −20%
          </p>
        </div>
        <p>
          Tip: hit nearer the paddle’s edge to bend the shot.
          The Network tracks imperfectly — exploit it.
        </p>
        <div class="btnrow">
          <button id="closeHelpBtn">Close (H)</button>
        </div>
      </div>
    </div>

    <!-- Start / End Overlay -->
    <div id="mainOverlay" class="overlay show" role="dialog" aria-modal="true" aria-label="Game menu">
      <div class="panel" style="text-align:center;">
        <h1 id="title" class="glitchy">ROBOT LEARNS SITCOM</h1>
        <p id="subtitle">PRESS ANY KEY TO INITIALIZE</p>
        <p style="opacity:.8;margin-top:12px;">
          <span class="kbd">H</span> How to play · <span class="kbd">M</span> Sound · <span class="kbd">R</span> Restart
        </p>
        <div class="btnrow" style="justify-content:center;">
          <button id="startBtn">Start</button>
          <button id="helpBtn">How to play</button>
          <button id="soundBtn">Sound: On</button>
        </div>
      </div>
    </div>

    <span class="sr-only" id="ariaLive" aria-live="polite"></span>
  </div>

<script>
(() => {
  // Canvas + context
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;

  // DOM HUD
  const batteryChip = document.getElementById("batteryChip");
  const humanChip   = document.getElementById("humanChip");
  const statusChip  = document.getElementById("statusChip");
  const soundChip   = document.getElementById("soundChip");
  const shopChip    = document.getElementById("shopChip");
  const ariaLive    = document.getElementById("ariaLive");

  const mainOverlay = document.getElementById("mainOverlay");
  const howOverlay  = document.getElementById("howOverlay");
  const titleEl     = document.getElementById("title");
  const subtitleEl  = document.getElementById("subtitle");
  const startBtn    = document.getElementById("startBtn");
  const helpBtn     = document.getElementById("helpBtn");
  const closeHelpBtn= document.getElementById("closeHelpBtn");
  const soundBtn    = document.getElementById("soundBtn");

  // --- Config ---
  const W = canvas.width, H = canvas.height;
  const NET_X = W / 2;

  const PADDLE_W = 20;
  const PADDLE_H = 80;
  const PADDLE_SPEED = 460;

  const BALL_SIZE = 12;
  const BALL_SPEED_START = 420;
  const SPEED_INC_ON_HIT = 22;

  const COLOR_BG = "rgb(10,25,10)";
  const C_NEON = "rgb(50,255,50)";
  const C_DARK = "rgb(20,100,20)";
  const C_ALERT= "rgb(255,50,50)";
  const C_WHITE= "rgb(245,245,245)";

  // --- Audio (WebAudio) ---
  let audioCtx = null;
  let soundOn = true;

  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  function beep(freq=440, dur=0.06, type="square", vol=0.04) {
    if (!soundOn) return;
    ensureAudio();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }

  // --- Utilities ---
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const now = () => performance.now();

  function announce(msg){
    ariaLive.textContent = msg;
  }

  // --- Game State ---
  let state = "menu"; // menu | playing | win | lose
  let lastT = now();
  let timeScale = 1;

  let battery = 100;
  let humanity = 0;

  let shakeT = 0;
  let shakeMag = 0;

  const player = {
    x: 40, y: H/2,
    w: PADDLE_W, h: PADDLE_H,
    baseH: PADDLE_H,
    bigUntil: 0
  };

  const enemy = {
    x: W - 40, y: H/2,
    w: PADDLE_W, h: PADDLE_H,
    speed: 320,
    // imperfection
    reaction: 0,
    aimJitter: 0
  };

  let balls = [];
  let particles = [];
  let floaties = [];
  let flashes = []; // screen flashes

  function makeBall(x, y, angleDeg, speed){
    const a = angleDeg * Math.PI / 180;
    return {
      x, y,
      vx: Math.cos(a) * speed,
      vy: Math.sin(a) * speed,
      speed,
      alive: true
    };
  }

  // --- Reset / Start ---
  function resetRun() {
    battery = 100;
    humanity = 0;
    timeScale = 1;
    balls = [];
    particles = [];
    floaties = [];
    flashes = [];
    player.y = H/2;
    player.h = player.baseH;
    player.bigUntil = 0;
    enemy.y = H/2;
    enemy.h = PADDLE_H;
    enemy.reaction = 0;
    enemy.aimJitter = 0;
    spawnServe("right");
    updateHUD();
    statusChip.textContent = "STATUS: LIVE";
    statusChip.classList.remove("alert");
  }

  function spawnServe(dir){
    const angle = rand(-25, 25) + (dir === "right" ? 0 : 180);
    balls.push(makeBall(W/2, H/2, angle, BALL_SPEED_START));
    beep(dir === "right" ? 600 : 420, 0.05, "square", 0.03);
  }

  // --- HUD ---
  function updateHUD(){
    battery = Math.round(clamp(battery, 0, 100));
    humanity = Math.round(clamp(humanity, 0, 100));
    batteryChip.textContent = `BATTERY: ${battery}%`;
    humanChip.textContent   = `HUMANITY: ${humanity}%`;

    batteryChip.classList.toggle("alert", battery < 30);
    soundChip.textContent = `SOUND: ${soundOn ? "ON" : "OFF"} (M)`;
    soundBtn.textContent = `Sound: ${soundOn ? "On" : "Off"}`;
  }

  function addFlash(color="rgba(255,0,0,.25)", dur=120){
    flashes.push({color, t: dur});
  }

  function shake(mag=8, dur=180){
    shakeMag = Math.max(shakeMag, mag);
    shakeT = Math.max(shakeT, dur);
  }

  function addParticles(x, y, n=8){
    for(let i=0;i<n;i++){
      const a = rand(0, Math.PI*2);
      const s = rand(60, 180);
      particles.push({
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        t: rand(180, 320),
        size: rand(2, 4)
      });
    }
  }

  function addFloaty(txt, x, y, color=C_NEON){
    floaties.push({txt, x, y, vy: -40, t: 520, color});
  }

  function setShopTemp(msg, ms=650, isAlert=false){
    shopChip.textContent = msg;
    shopChip.style.color = isAlert ? "rgba(255,50,50,.95)" : "rgba(50,255,50,.75)";
    window.clearTimeout(setShopTemp._t);
    setShopTemp._t = window.setTimeout(() => {
      shopChip.textContent = "[1] SIZE (-15%) · [2] SLOW (-10%) · [3] MULTI (-20%)";
      shopChip.style.color = "rgba(50,255,50,.75)";
    }, ms);
  }

  // --- Collisions ---
  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function ballRectCollision(ball, rx, ry, rw, rh){
    const bx = ball.x - BALL_SIZE/2;
    const by = ball.y - BALL_SIZE/2;
    return rectsOverlap(bx, by, BALL_SIZE, BALL_SIZE, rx - rw/2, ry - rh/2, rw, rh);
  }

  // --- Battery/Humanity updates ---
  function modBattery(delta){
    battery += delta;
    if (delta < 0){
      addFlash("rgba(255,0,0,.22)", 110);
      shake(10, 180);
      beep(160, 0.08, "sawtooth", 0.03);
    } else {
      beep(520, 0.05, "square", 0.02);
    }
    updateHUD();
    if (battery <= 0){
      battery = 0;
      lose();
    }
  }

  function modHumanity(delta){
    humanity += delta;
    addFlash("rgba(50,255,50,.12)", 120);
    addFloaty("Ha!", W/2 + rand(-20, 20), 80 + rand(-10, 10), "rgba(50,255,50,.9)");
    beep(740, 0.05, "square", 0.03);
    updateHUD();
    if (humanity >= 100){
      humanity = 100;
      win();
    }
  }

  // --- Win/Lose ---
  function win(){
    state = "win";
    statusChip.textContent = "STATUS: PRIME TIME";
    statusChip.classList.remove("alert");
    subtitleEl.textContent = "HUMANITY ACHIEVED — PRESS R TO REBOOT";
    mainOverlay.classList.add("show");
    titleEl.textContent = "HUMANITY ACHIEVED";
    addFlash("rgba(50,255,50,.35)", 250);
    announce("You won. Press R to restart.");
    beep(880, 0.08, "square", 0.04);
    beep(660, 0.08, "square", 0.035);
    beep(990, 0.12, "square", 0.03);
  }

  function lose(){
    state = "lose";
    statusChip.textContent = "STATUS: FAILURE";
    statusChip.classList.add("alert");
    subtitleEl.textContent = "SYSTEM FAILURE — PRESS R TO REBOOT";
    mainOverlay.classList.add("show");
    titleEl.textContent = "SYSTEM FAILURE";
    addFlash("rgba(255,50,50,.28)", 260);
    announce("You lost. Press R to restart.");
    beep(120, 0.12, "sawtooth", 0.04);
    beep(90, 0.14, "sawtooth", 0.03);
  }

  // --- Input ---
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    // Prevent scrolling with arrows/space
    if (["ArrowUp","ArrowDown"," "].includes(e.key)) e.preventDefault();

    keys.add(e.key.toLowerCase());

    // Any key starts from menu (except when help is open)
    if (state === "menu" && !howOverlay.classList.contains("show")) {
      startGame();
    }
  }, {passive:false});

  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  function startGame(){
    mainOverlay.classList.remove("show");
    howOverlay.classList.remove("show");
    state = "playing";
    resetRun();
    canvas.focus();
    announce("Game started.");
  }

  function toggleHelp(){
    const show = !howOverlay.classList.contains("show");
    howOverlay.classList.toggle("show", show);
    if (show) {
      announce("How to play opened. Press H to close.");
      closeHelpBtn.focus();
    } else {
      announce("How to play closed.");
      canvas.focus();
    }
  }

  function toggleSound(){
    soundOn = !soundOn;
    updateHUD();
    setShopTemp(soundOn ? "SOUND ONLINE" : "SOUND MUTED", 550, false);
    if (soundOn) beep(520, 0.05, "square", 0.03);
  }

  // Buttons
  startBtn.addEventListener("click", startGame);
  helpBtn.addEventListener("click", toggleHelp);
  closeHelpBtn.addEventListener("click", toggleHelp);
  soundBtn.addEventListener("click", toggleSound);

  // Main hotkeys
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    if (k === "h") toggleHelp();
    if (k === "m") toggleSound();
    if (k === "r") {
      if (state === "playing") {
        setShopTemp("REBOOTING…", 450, false);
      }
      if (howOverlay.classList.contains("show")) howOverlay.classList.remove("show");
      state = "playing";
      mainOverlay.classList.remove("show");
      resetRun();
      canvas.focus();
      announce("Restarted.");
    }

    // Shop (only in play and when help is closed)
    if (state !== "playing" || howOverlay.classList.contains("show")) return;

    if (k === "1") buyBigPaddle();
    if (k === "2") buySlowTime();
    if (k === "3") buyMultiBall();
  });

  // --- Shop mechanics ---
  function insufficient(){
    setShopTemp("LOW BATTERY!!!", 650, true);
    shake(5, 140);
    beep(210, 0.06, "square", 0.02);
  }

  function buyBigPaddle(){
    if (battery < 15) return insufficient();
    modBattery(-15);
    player.h = 150;
    player.bigUntil = now() + 8000;
    setShopTemp("UPGRADE: BIG PADDLE ACQUIRED", 750, false);
    addParticles(player.x + 20, player.y, 10);
    beep(560, 0.06, "square", 0.03);
  }

  function buySlowTime(){
    if (battery < 10) return insufficient();
    modBattery(-10);
    timeScale = 0.5;
    setShopTemp("UPGRADE: MATRIX MODE", 650, false);
    addFlash("rgba(80,255,80,.10)", 180);
    // restore after 2s real-time
    const restoreAt = now() + 2000;
    buySlowTime._restoreAt = restoreAt;
    beep(360, 0.08, "triangle", 0.03);
  }

  function buyMultiBall(){
    if (battery < 20) return insufficient();
    modBattery(-20);
    const ref = balls.find(b => b.alive) || {x:W/2,y:H/2};
    const base = BALL_SPEED_START + 40;
    balls.push(makeBall(ref.x, ref.y, -28, base));
    balls.push(makeBall(ref.x, ref.y,  28, base));
    setShopTemp("UPGRADE: CANNED LAUGHTER", 700, false);
    addParticles(ref.x, ref.y, 14);
    beep(820, 0.05, "square", 0.03);
    beep(620, 0.05, "square", 0.03);
  }

  // --- Main update loop ---
  function update(dt){
    // dt in seconds, apply timeScale for gameplay
    const t = now();

    // big paddle timeout
    if (player.bigUntil && t > player.bigUntil){
      player.h = player.baseH;
      player.bigUntil = 0;
      setShopTemp("BIG PADDLE EXPIRED", 550, false);
      beep(300, 0.05, "square", 0.02);
    }

    // slow time restore
    if (buySlowTime._restoreAt && t > buySlowTime._restoreAt){
      timeScale = 1;
      buySlowTime._restoreAt = 0;
      setShopTemp("TIME NORMALIZED", 550, false);
      beep(520, 0.05, "square", 0.02);
    }

    // Player input
    let dy = 0;
    if (keys.has("arrowup") || keys.has("w")) dy -= 1;
    if (keys.has("arrowdown") || keys.has("s")) dy += 1;
    player.y += dy * PADDLE_SPEED * dt;
    player.y = clamp(player.y, player.h/2, H - player.h/2);

    // Enemy AI (imperfect)
    enemy.reaction -= dt;
    if (enemy.reaction <= 0){
      enemy.reaction = rand(0.06, 0.14);
      enemy.aimJitter = rand(-18, 18);
    }

    // choose nearest incoming ball (moving to the right)
    const incoming = balls.filter(b => b.alive && b.vx > 0);
    let targetY = H/2;
    if (incoming.length){
      incoming.sort((a,b) => b.x - a.x);
      targetY = incoming[0].y + enemy.aimJitter;
    }
    const dir = Math.sign(targetY - enemy.y);
    enemy.y += dir * enemy.speed * dt * 0.92;
    enemy.y = clamp(enemy.y, enemy.h/2, H - enemy.h/2);

    // Balls
    for (const b of balls){
      if (!b.alive) continue;

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // wall bounce
      if (b.y < BALL_SIZE/2){
        b.y = BALL_SIZE/2;
        b.vy *= -1;
        addParticles(b.x, b.y, 6);
        beep(520, 0.03, "square", 0.02);
      } else if (b.y > H - BALL_SIZE/2){
        b.y = H - BALL_SIZE/2;
        b.vy *= -1;
        addParticles(b.x, b.y, 6);
        beep(520, 0.03, "square", 0.02);
      }

      // paddle collisions
      if (ballRectCollision(b, player.x, player.y, player.w, player.h) && b.vx < 0){
        // angle based on impact point
        const rel = (b.y - player.y) / (player.h/2); // -1..1
        const ang = clamp(rel, -1, 1) * 60; // degrees
        const spd = Math.min(900, Math.hypot(b.vx, b.vy) + SPEED_INC_ON_HIT);
        const a = ang * Math.PI / 180;
        b.vx = Math.cos(a) * spd;
        b.vy = Math.sin(a) * spd;
        // ensure to the right
        if (b.vx < 120) b.vx = 120;
        addParticles(b.x, b.y, 10);
        addFloaty("Ha!", b.x + 8, b.y - 8, "rgba(50,255,50,.9)");
        beep(740, 0.04, "square", 0.03);
      }

      if (ballRectCollision(b, enemy.x, enemy.y, enemy.w, enemy.h) && b.vx > 0){
        const rel = (b.y - enemy.y) / (enemy.h/2);
        const ang = 180 - clamp(rel, -1, 1) * 55;
        const spd = Math.min(900, Math.hypot(b.vx, b.vy) + SPEED_INC_ON_HIT);
        const a = ang * Math.PI / 180;
        b.vx = Math.cos(a) * spd;
        b.vy = Math.sin(a) * spd;
        // ensure to the left
        if (b.vx > -120) b.vx = -120;
        addParticles(b.x, b.y, 10);
        beep(520, 0.04, "square", 0.025);
      }

      // score logic
      if (b.x < -BALL_SIZE){
        b.alive = false;
        modBattery(-15);
      } else if (b.x > W + BALL_SIZE){
        b.alive = false;
        modHumanity(10);
      }
    }

    // respawn if all dead
    if (balls.every(b => !b.alive)) {
      // delay serve a bit
      if (!update._respawnAt) update._respawnAt = now() + 650;
      if (now() > update._respawnAt){
        update._respawnAt = 0;
        // alternate serve direction based on last score feel
        const dir = (Math.random() < 0.5) ? "right" : "left";
        spawnServe(dir);
      }
    }

    // Particles
    for (const p of particles){
      p.t -= dt * 1000;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - 2.2*dt);
      p.vy *= (1 - 2.2*dt);
    }
    particles = particles.filter(p => p.t > 0);

    // Floaty texts
    for (const f of floaties){
      f.t -= dt * 1000;
      f.y += f.vy * dt;
    }
    floaties = floaties.filter(f => f.t > 0);

    // Flashes
    for (const fl of flashes){
      fl.t -= dt * 1000;
    }
    flashes = flashes.filter(fl => fl.t > 0);

    // Shake
    if (shakeT > 0){
      shakeT -= dt * 1000;
      if (shakeT <= 0){ shakeT = 0; shakeMag = 0; }
    }

    // tiny title glitch in menu
    if (state === "menu"){
      titleEl.style.transform = `translate(${rand(-2,2)}px, ${rand(-1,1)}px)`;
    } else {
      titleEl.style.transform = "";
    }
  }

  // --- Render ---
  function render(){
    ctx.clearRect(0,0,W,H);

    // screen shake
    let ox = 0, oy = 0;
    if (shakeT > 0){
      const s = shakeMag * (shakeT / 180);
      ox = rand(-s, s);
      oy = rand(-s, s);
    }
    ctx.save();
    ctx.translate(ox, oy);

    // background
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0,0,W,H);

    // center net
    ctx.fillStyle = "rgba(20,100,20,0.55)";
    ctx.fillRect(NET_X - 1, 0, 2, H);
    ctx.fillStyle = "rgba(50,255,50,0.08)";
    for (let y=0;y<H;y+=18){
      ctx.fillRect(NET_X - 2, y+6, 4, 6);
    }

    // paddles
    ctx.fillStyle = C_NEON;
    ctx.fillRect(player.x - player.w/2, player.y - player.h/2, player.w, player.h);

    ctx.fillStyle = C_ALERT;
    ctx.fillRect(enemy.x - enemy.w/2, enemy.y - enemy.h/2, enemy.w, enemy.h);

    // balls
    for (const b of balls){
      if (!b.alive) continue;
      ctx.fillStyle = C_WHITE;
      ctx.fillRect(b.x - BALL_SIZE/2, b.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);
      // tiny glow
      ctx.fillStyle = "rgba(245,245,245,0.12)";
      ctx.fillRect(b.x - BALL_SIZE, b.y - BALL_SIZE, BALL_SIZE*2, BALL_SIZE*2);
    }

    // particles
    ctx.fillStyle = C_NEON;
    for (const p of particles){
      const a = clamp(p.t/320, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.globalAlpha = 1;

    // floaty texts
    for (const f of floaties){
      const a = clamp(f.t/520, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = f.color;
      ctx.font = "14px ui-monospace, Menlo, Consolas, monospace";
      ctx.fillText(f.txt, f.x, f.y);
    }
    ctx.globalAlpha = 1;

    // vignette-ish inner border
    ctx.strokeStyle = "rgba(50,255,50,.10)";
    ctx.lineWidth = 2;
    ctx.strokeRect(6,6,W-12,H-12);

    // flashes
    for (const fl of flashes){
      ctx.globalAlpha = clamp(fl.t/120, 0, 1);
      ctx.fillStyle = fl.color;
      ctx.fillRect(0,0,W,H);
    }
    ctx.globalAlpha = 1;

    ctx.restore();

    // in-game title “subtitles” (lightweight, feels like a sitcom)
    if (state === "playing" && Math.random() < 0.006){
      const zingers = [
        "LAUGH TRACK: ENGAGED",
        "NETWORK EXECUTIVE: DISPLEASED",
        "JOKE UNDERSTOOD… PROBABLY",
        "PUNCHLINE DETECTED",
        "SITUATION: COMEDY",
        "CUT TO COMMERCIAL!",
        "ROBOT: CHUCKLING (SIMULATED)"
      ];
      addFloaty(zingers[(Math.random()*zingers.length)|0], 20 + rand(0, 200), 100 + rand(0, 380), "rgba(50,255,50,.65)");
    }
  }

  function loopFrame(){
    const t = now();
    let dt = (t - lastT) / 1000;
    lastT = t;
    dt = Math.min(dt, 0.04); // stability
    if (state === "playing" && !howOverlay.classList.contains("show")){
      update(dt * timeScale);
      render();
    } else {
      // keep a soft render even in menus, so it feels alive
      render();
    }
    requestAnimationFrame(loopFrame);
  }

  // --- Menu setup ---
  function enterMenu(){
    state = "menu";
    titleEl.textContent = "ROBOT LEARNS SITCOM";
    subtitleEl.textContent = "PRESS ANY KEY TO INITIALIZE";
    mainOverlay.classList.add("show");
    updateHUD();
    statusChip.textContent = "STATUS: READY";
    statusChip.classList.remove("alert");
    announce("Menu. Press any key to start.");
  }

  // Start in menu
  enterMenu();
  updateHUD();
  requestAnimationFrame(loopFrame);

  // Let canvas receive focus for keyboard play
  canvas.addEventListener("pointerdown", () => {
    canvas.focus();
    // unlock audio in browsers that require a gesture
    ensureAudio();
  });

})();
</script>
</body>
</html>
